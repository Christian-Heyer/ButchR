% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integrativeNMF_functions.R
\name{iNMF_lambda_tuning}
\alias{iNMF_lambda_tuning}
\title{Integrative NMF Tune Lambda}
\usage{
iNMF_lambda_tuning(
  matrix_list,
  lambdas = seq(0, 1, 0.1),
  Output_type = "residuals",
  thr_cons = 3,
  rank = 2,
  n_initializations = 10,
  iterations = 10^4,
  convergence_threshold = 40,
  Sp = 0,
  show_plot = TRUE,
  extract_features = FALSE
)
}
\arguments{
\item{matrix_list}{List of non-negative matrices.}

\item{lambdas}{a sequence of lambdas to test.}

\item{Output_type}{Type of desired output, could be:
\itemize{
\item residuals - Residual quantities data.frame.
\item iNMF - Returns the integrative NMF object for the optimal estimated lambda.
\item all_iNMF - Returns a list with an integrative NMF object for every  lambda.
\item plot - Residual quantities plot,
(Ri - Rj) and 2(Rj - Rs) vs lamda range.
\item all - list containing all computed NMF objects,
Residual quantities data.frame and Residual quantities plot.
}}

\item{thr_cons}{numeric value, Threshold constant c, in  c*(Rj - Rs).}

\item{rank}{numeric vector with rank to factorize.}

\item{n_initializations}{Number of initializations to evaluate.}

\item{iterations}{Maximum number of iterations to run for every initialization.}

\item{convergence_threshold}{The factorization stops,
if the convergence test is constant for this number of iterations.}

\item{Sp}{Sparcity constrain, values > 0 force sparcity in the H matrix.}

\item{show_plot}{\code{TRUE} print plot;
\code{FALSE} plot is only returned if it is selected in Output_type.}

\item{extract_features}{\code{TRUE} Extract signature specific features.}
}
\value{
There are five different types of possible outputs, depending on the
selected option on `Output_type`. The default output is a data.frame with
the residual resulting from tuning lambdas across multiple lambdas.
}
\description{
Based on Yang and Michailidis, 2016,
to tune the value of the parameter lambda for the integrative NMF (iNMF),
the objectives values of join NMF (jNMF) are compared to
single view NMFs (sNMF), the principle is that join NMF
represents complete homogeneity and single view NMF
represents complete heterogeneity.
To avoid overfitting the best lambda can be selected by plotting
the difference of the unsquared residual quantities of
jNMF and iNMF (Ri - Rj) over multiple values of lambda,
and compare it to the difference of the unsquared residual quantities of
sNMF and jNMF c*(Rj - Rs).
The optimal lambda usually is the first lambda in which
(Ri - Rj) < c*(Rj - Rs).
Where c is a constant >= 2.
}
\examples{
\dontrun{
# Compare the residual across multiple lambdas:
iNMF_lambda_tuning(matrix_list           = norm_mat_list,
                   lambdas               = seq(0, 1, 0.1),
                   Output_type           = "residuals",
                   rank                  = 9,
                   n_initializations     = 5,
                   iterations            = 10^4,
                   convergence_threshold = 40,
                   Sp                    = 0,
                   extract_features      = FALSE)
# Retrieve all the objects and extract the iNMF for the best lambda:
inmf_tune <- iNMF_lambda_tuning(matrix_list           = norm_mat_list,
                                lambdas               = seq(0, 1, 0.1),
                                thr_cons              = 4,
                                Output_type           = "all",
                                rank                  = 9,
                                n_initializations     = 5,
                                iterations            = 10^4,
                                convergence_threshold = 40)
min(inmf_tune$residuals$lambda[inmf_tune$residuals$best_lambda])
inmf_tune$iNMF$lambda_0.2
}
}
