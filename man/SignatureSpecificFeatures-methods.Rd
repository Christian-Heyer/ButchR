% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/nmfExperiment-class_lite.R,
%   R/integrativeNMF-class.R, R/joinNMF-class.R
\docType{methods}
\name{SignatureSpecificFeatures}
\alias{SignatureSpecificFeatures}
\alias{SignatureSpecificFeatures,nmfExperiment_lite-method}
\alias{SignatureSpecificFeatures,ANY-method}
\alias{SignatureSpecificFeatures,integrative_NMF-method}
\alias{SignatureSpecificFeatures,join_NMF-method}
\title{Signature Specific Features}
\usage{
SignatureSpecificFeatures(x, k = NULL, return_all_features = FALSE, ...)

\S4method{SignatureSpecificFeatures}{nmfExperiment_lite}(x, k = NULL, return_all_features = FALSE, ...)

\S4method{SignatureSpecificFeatures}{integrative_NMF}(
  x,
  k = NULL,
  return_all_features = FALSE,
  view_id = NULL,
  ...
)

\S4method{SignatureSpecificFeatures}{join_NMF}(
  x,
  k = NULL,
  return_all_features = FALSE,
  view_id = NULL,
  ...
)
}
\arguments{
\item{x}{an nmfExperiment or a nmfExperiment_lite object}

\item{k}{numeric  - factorization rank}

\item{view_id}{character vector with views from which sigature specific
features will be extracted.}
}
\value{
list of signature specific fatures or binary matrices for all features
}
\description{
Returns the list of signatures specific features
for all factorization ranks or for the indicaded rank,
if return_all_features = TRUE
returns a binary matrix for every factorization rank,
with features in the rows and samples in the columns,
in which 1 means that the features is contributing to the signature,
and 0 it does not.
The extraction of Signature Specific Features is not supported for k = 2
}
\examples{
data("leukemia")
nmf_exp <- runNMFtensor_lite(leukemia$matrix, ranks = 3,
                             method = "NMF",
                             n_initializations = 2,
                             extract_features = TRUE)
SignatureSpecificFeatures(nmf_exp)
SignatureSpecificFeatures(nmf_exp, k = 3)
SignatureSpecificFeatures(nmf_exp, k = 3, return_all_features = TRUE)
\dontrun{
# For nmfExperiment_lite objects:
SignatureSpecificFeatures(nmf_exp)
lapply(SignatureSpecificFeatures(nmf_exp), function(x) sapply(x, length))
SignatureSpecificFeatures(nmf_exp, k = 3)
SignatureSpecificFeatures(nmf_exp, k = 3, return_all_features = TRUE)
}
\dontrun{
# For integrative_NMF objects:
SignatureSpecificFeatures(inmf_exp)
lapply(SignatureSpecificFeatures(inmf_exp), function(view){
  sapply(view, function(x) sapply(x, length))
} )
lapply(SignatureSpecificFeatures(inmf_exp, k = 3), function(view){
  sapply(view, length)
})
SignatureSpecificFeatures(inmf_exp, k = 3, return_all_features = TRUE)
SignatureSpecificFeatures(inmf_exp, k = 3,
                          return_all_features = TRUE,
                          view_id = "atac")
SignatureSpecificFeatures(inmf_exp,
                          return_all_features = TRUE,
                          view_id = "atac")
}

\dontrun{
# For join_NMF objects:
SignatureSpecificFeatures(jnmf_exp)
SignatureSpecificFeatures(jnmf_exp)
lapply(SignatureSpecificFeatures(jnmf_exp), function(view){
  sapply(view, function(x) sapply(x, length))
})
lapply(SignatureSpecificFeatures(jnmf_exp, k = 3), function(view){
  sapply(view, length)
})
SignatureSpecificFeatures(jnmf_exp, k = 3, return_all_features = TRUE)
SignatureSpecificFeatures(jnmf_exp, k = 3,
                          return_all_features = TRUE,
                          view_id = "atac")
SignatureSpecificFeatures(jnmf_exp,
                          return_all_features = TRUE,
                          view_id = "atac")
}
}
